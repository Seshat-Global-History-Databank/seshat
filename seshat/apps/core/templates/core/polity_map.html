{% load leaflet_tags %}

<head>
    {% leaflet_js %}
    {% leaflet_css %}
    {% load static %}
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
</head>

<style>
    input {
        accent-color: teal;
    }
</style>

<body>
    {% block content %}
    {% if content.include_polity_map %}
        <div style="display: flex;">
            <div style="width: 20%">
                <fieldset>
		            <div>
			            <h2 class="h1 text-teal federicka-big" id="sliderDate"></h2>
                        <label for="enterYear">Enter year:</label>
                        <input type="number" id="enterYear" name="enterYear" value="{{ content.display_year }}" style="width: 75px;""><br>
                        <label for="enterYear">Increment (years):</label>
                        <input type="number" id="increment" name="increment" value="10" style="width: 50px;" onchange="playRateValue()">
                        <button id=" minusButton" type="button" onclick="adjustSliderDown()">-</button>
                        <button id="plusButton" type="button" onclick="adjustSliderUp()">+</button><br>
                        <label for="playRate">Play rate: </label>
                        <span id="playRate">10 y/s</span><br>
                        <label for="playButton">Run animation:</label>
                        <button id="playButton" type="button" onclick="startPlay()">▶️</button>
                        <button id="stopButton" type="button" onclick="stopPlay()">⏸</button><br>
                        <label for="switchPolitiesComponents">Display:</label>
                        <select name="switchPolitiesComponents" id="switchPolitiesComponents" onchange="plotPolities()">
                            <option value="components">Polity components</option>
                            <option value="polities">Full polities</option>
                        </select><br>
                        <label for="opacitySlide">Opacity:</label>
                        <input type="range" name="opacitySlide" id="opacitySlide" min="0.1" max="1" step="0.1" value="0.5" class="slider"
                            onchange="plotPolities()" style="width: 150px;">
                        <fieldset>
                            <br>
                            <label for="baseMapOnly">Base map only</label>
                            <input type="checkbox" id="baseMapOnly" name="baseMapOnly" onclick=plotPolities()><br><br>
                            <label><input type="radio" name="baseMap" id="baseMapBasic" value="cartobasic" onclick="switchBaseMap()"
                                    checked>Basic</label><br>
                            <label><input type="radio" name="baseMap" id="baseMapOSM" value="osm"
                                    onclick="switchBaseMap()">OpenStreetMap</label><br>
                            <label><input type="radio" name="baseMap" id="baseMapCurrent" value="gadm" onclick="switchBaseMap()"
                                    disabled>Current borders</label>
                            <!-- Add a loading indicator for Current borders -->
                            <div id="baseMapCurrentLoadingIndicator">
                                <p><sub>Loading current borders...</sub></p>
                                <!-- <div class="spinner"></div> -->
                            </div><br>
                        </fieldset>
                        <fieldset id="baseMapGADMFieldset">
                            <label for="baseMapGADM">Current borders:</label>
                            <select name="baseMapGADM" id="baseMapGADM" onchange="switchBaseMap()">
                                <option value="country">Countries</option>
                                <option value="province">Provinces</option>
                            </select><br>
                        </fieldset>
                    </div>
                </fieldset>
            </div>
            <div style="display: flex; flex-direction: column; width: 80%; height: 60vh;">
                <div id="map" style="flex: 1; width: 100%"></div>
                <div style="display: block; width: 100%">
                    <fieldset>
                        <div class="slider-container" style="position: relative;">
                            <datalist id="yearTickmarks"></datalist>
                            <input type="range" name="dateSlide" id="dateSlide" min="{{ content.earliest_year }}" max="{{ content.latest_year }}"
                                value="{{ content.display_year }}" class="slider" onchange="plotPolities()" style="width: 100%;"
                                list="yearTickmarks">
                            <div id="yearTickmarkValues"></div>
                        </div>
                    </fieldset>
                </div>
            </div>
        </div>
        <script src="{% static 'core/js/map_functions.js' %}"></script>
        <script>

            function updateSliderOutput() {
                if (slider.value < 0) {
                    output.innerHTML = Math.abs(slider.value) + ' BCE';
                } else {
                    output.innerHTML = slider.value + ' CE';
                }
            }

            function adjustSliderUp() {
                increment = Number(document.getElementById('increment').value)
                slider.value = Number(slider.value) + increment;
                enterYearInput.value = slider.value; // Sync enterYear input with dateSlide value
                updateSliderOutput(); // Update the displayed year
                plotPolities(); // This function is defined differently in the world_map and polity_map templates
            }

            function adjustSliderDown() {
                increment = Number(document.getElementById('increment').value)
                slider.value = Number(slider.value) - increment;
                enterYearInput.value = slider.value; // Sync enterYear input with dateSlide value
                updateSliderOutput(); // Update the displayed year
                plotPolities(); // This function is defined differently in the world_map and polity_map templates
            }

            function adjustSliderStartYear() {
                slider.value = slider.min;
                enterYearInput.value = slider.value; // Sync enterYear input with dateSlide value
                updateSliderOutput(); // Update the displayed year
                plotPolities(); // This function is defined differently in the world_map and polity_map templates
            }

            function adjustSliderEndYear() {
                slider.value = slider.max;
                enterYearInput.value = slider.value; // Sync enterYear input with dateSlide value
                updateSliderOutput(); // Update the displayed year
                plotPolities(); // This function is defined differently in the world_map and polity_map templates
            }

            function playRateValue() {
                var increment = Number(document.getElementById('increment').value);
                var playRate = document.getElementById('playRate')
                playRate.textContent = increment + ' y/s';
                plotPolities();
            }

            function setSliderTicks(tickYears) {
                var datalist = document.getElementById('yearTickmarks');
                var tickmarkValuesDiv = document.getElementById('yearTickmarkValues');

                // If the data list already has options, remove them
                while (datalist.firstChild) {
                    datalist.removeChild(datalist.firstChild);
                };
                // If the tickmark values div already has spans, remove them
                while (tickmarkValuesDiv.firstChild) {
                    tickmarkValuesDiv.removeChild(tickmarkValuesDiv.firstChild);
                };

                // Loop to add tickmarks
                i = 0;
                for (const tickValue of tickYears) {
                    var option = document.createElement('option');
                    option.value = tickValue;
                    datalist.appendChild(option);

                    // Create and add corresponding span for tickmark labels
                    var span = document.createElement('span');
                    span.textContent = tickValue;
                    span.style.position = 'absolute';
                    span.style.textAlign = 'center';

                    // Use transform to center the span over the tickmark, with special handling for the first and last span
                    var leftPercentage = (i / (tickYears.length - 1) * 100);
                    span.style.left = `${leftPercentage}%`;
                    if (i === 0) {
                        span.style.transform = 'translateX(0%)'; // No translation for the first span
                        span.style.textAlign = 'left'; // Align text to the left for the first span
                    } else if (i === (tickYears.length - 1)) {
                        span.style.transform = 'translateX(-100%)'; // Adjust the last span to prevent overflow
                    } else {
                        span.style.transform = 'translateX(-50%)'; // Center all other spans
                    }
                    tickmarkValuesDiv.appendChild(span);
                    i++;
                }
            };

            function startPlay() {
                stopPlay(); // Clear existing interval before starting a new one
                var increment = Number(document.getElementById('increment').value);

                var milliseconds = 1 / (increment / 1000);

                playInterval = setInterval(function () {
                    // Increment the slider value by 1
                    slider.value = Number(slider.value) + 1;
                    enterYearInput.value = slider.value; // Sync enterYear input with dateSlide value
                    updateSliderOutput(); // Update the displayed year
                    plotPolities(); // This function is defined differently in the world_map and polity_map templates

                    // Stop playing when the slider reaches its maximum value
                    if (slider.value >= parseInt(slider.max)) {
                        stopPlay();
                    }
                }, milliseconds); // Interval based on user input
            }

            function stopPlay() {
                clearInterval(playInterval);
            }

            function storeYear() {
                var year = document.getElementById('enterYear').value;
                history.pushState(null, '', '/core/world_map/?year=' + year);
                if (!allPolitiesLoaded) {
                    document.getElementById('loadingIndicator').style.display = 'block';
                }
            }

            function switchBaseMap() {
                var selectedMap = document.querySelector('input[name="baseMap"]:checked').value;
                var base = document.getElementById("baseMapGADM").value

                if (base == 'province') {
                    var baseShapeData = provinceShapeData;
                } else if (base == 'country') {
                    var baseShapeData = countryShapeData;
                }

                // Only show "Current borders" select for GADM
                var baseMapGADMFieldset = document.getElementById("baseMapGADMFieldset");
                if (selectedMap == 'gadm') {
                    baseMapGADMFieldset.style.display = "block"
                } else {
                    baseMapGADMFieldset.style.display = "none"
                }

                // Remove all province layers
                provinceLayers.forEach(function (layer) {
                    map.removeLayer(layer);
                });

                // Clear the provinceLayers array
                provinceLayers = [];

                map.removeLayer(currentLayer);

                if (selectedMap === 'osm') {
                    currentLayer = baseLayers.osm.addTo(map);
                } else {
                    currentLayer = baseLayers.carto.addTo(map);
                }

                if (selectedMap === 'gadm') {
                    // Add countries or provinces to the base map
                    baseShapeData.forEach(function (shape) {
                        // Ensure the geometry is not empty
                        if (shape.geometry && shape.geometry.type) {
                            gadmFillColour = "#fffdf2";  // Default fill colour
                            if (shape.country.toLowerCase().includes('sea')) {
                                gadmFillColour = 'lightblue';
                            }
                            // Loop through each polygon and add it to the map
                            for (var i = 0; i < shape.geometry.coordinates.length; i++) {
                                var coordinates = shape.geometry.coordinates[i][0];
                                // Swap latitude and longitude for each coordinate
                                coordinates = coordinates.map(function (coord) {
                                    return [coord[1], coord[0]];
                                });
                                var polygon = L.polygon(coordinates).addTo(map);
                                if (!shape.country.toLowerCase().includes('sea')) {
                                    if (base == 'province') {
                                        var popupContent = `
                            <table>
                                <tr>
                                    <th>${shape.province}</th>
                                    <th></th>
                                </tr>
                                <tr>
                                    <td>Type</td>
                                    <td>${shape.provinceType}</td>
                                </tr>
                                <tr>
                                    <td>Country</td>
                                    <td>Modern ${shape.country}</td>
                                </tr>
                            </table>
                        `;
                                    } else if (base == 'country') {
                                        var popupContent = `
                            <table>
                                <tr>
                                    <th>Modern ${shape.country}</td>
                                </tr>
                            </table>
                        `;
                                    }
                                    polygon.bindPopup(popupContent);
                                };
                                // Set the style using the style method
                                polygon.setStyle({
                                    fillColor: gadmFillColour,   // Set the fill color based on the "colour" field
                                    color: 'black',       // Set the border color
                                    weight: 1,            // Set the border weight
                                    fillOpacity: 0.5        // Set the fill opacity
                                });
                                polygon.bringToBack(); // Move the province layers to back so they are always behind polity shapes
                                provinceLayers.push(polygon); // Add the layer to the array
                            }
                        }
                    });
                }
            }

            function updateLegend() {
                var variable = document.getElementById('chooseVariable').value;
                var legendDiv = document.getElementById('variableLegend');
                var selectedYear1 = document.getElementById('dateSlide').value;  // Giving it the same name as a var used in the templated JS caused an error
                var selectedYearInt1 = parseInt(selectedYear1);
                var displayComponent = document.getElementById('switchPolitiesComponents').value;

                // Clear the current legend
                legendDiv.innerHTML = '';

                if (variable == 'polity') {
                    var addedPolities = [];
                    var addedPolityNames = [];
                    shapesData.forEach(function (shape) {
                        shape_name_col_dict = {};
                        shape_name_col_dict['polity'] = shape.name;
                        shape_name_col_dict['colour'] = shape.colour;
                        if (shape.weight > 0 && !addedPolityNames.includes(shape_name_col_dict['polity'])) {
                            // If the shape spans the selected year and should be displayed according to the shouldDisplayComponent() function
                            if ((parseInt(shape.start_year) <= selectedYearInt1 && parseInt(shape.end_year) >= selectedYearInt1)
                                && shouldDisplayComponent(displayComponent, shape)
                            ) {
                                // Add the polity to the list of added polities
                                addedPolities.push(shape_name_col_dict);
                                addedPolityNames.push(shape_name_col_dict['polity']);
                            };
                        };
                    });

                    // Sort the polities by name
                    addedPolities.sort(function (a, b) {
                        return a.polity.localeCompare(b.polity);
                    });

                    // Add a legend for highlighted polities
                    if (addedPolities.length > 0) {
                        var legendTitle = document.createElement('h3');
                        legendTitle.textContent = 'Selected Polities';
                        legendDiv.appendChild(legendTitle);
                        for (var i = 0; i < addedPolities.length; i++) {
                            var legendItem = document.createElement('p');
                            var colorBox = document.createElement('span');
                            colorBox.style.display = 'inline-block';
                            colorBox.style.width = '20px';
                            colorBox.style.height = '20px';
                            colorBox.style.backgroundColor = addedPolities[i].colour;
                            colorBox.style.border = '1px solid black';
                            colorBox.style.marginRight = '10px';
                            legendItem.appendChild(colorBox);
                            legendItem.appendChild(document.createTextNode(addedPolities[i].polity));
                            legendDiv.appendChild(legendItem);
                        }
                    };

                } else if (variable in categorical_variables) {

                    var legendTitle = document.createElement('h3');
                    legendTitle.textContent = document.getElementById('chooseCategoricalVariableSelection').value;
                    legendDiv.appendChild(legendTitle);

                    for (var key in oneLanguageColourMapping) {
                        if (key === 'No Seshat page') {  // Skip the "No Seshat page" key as it's the same colour as "Uncoded" (see world_map.html)
                            continue;
                        }
                        var legendItem = document.createElement('p');

                        var colorBox = document.createElement('span');
                        colorBox.style.display = 'inline-block';
                        colorBox.style.width = '20px';
                        colorBox.style.height = '20px';
                        colorBox.style.backgroundColor = oneLanguageColourMapping[key];
                        colorBox.style.marginRight = '10px';
                        legendItem.appendChild(colorBox);

                        if (key === 'Unknown') {
                            colorBox.style.border = '1px solid black';
                        }
                        if (key === 'Unknown') {
                            legendItem.appendChild(document.createTextNode('Coded unknown'));
                        } else {
                            legendItem.appendChild(document.createTextNode(`${key}`));
                        }

                        legendDiv.appendChild(legendItem);
                    };

                } else {  // Absent-present variables
                    var legendTitle = document.createElement('h3');
                    legendTitle.textContent = variable;
                    legendDiv.appendChild(legendTitle);

                    for (var key in variableColourMapping) {
                        if (key === 'no seshat page') {  // Skip the "No Seshat page" key as it's the same colour as "Uncoded" (see world_map.html)
                            continue;
                        }
                        var legendItem = document.createElement('p');

                        var colorBox = document.createElement('span');
                        colorBox.style.display = 'inline-block';
                        colorBox.style.width = '20px';
                        colorBox.style.height = '20px';
                        colorBox.style.backgroundColor = variableColourMapping[key];
                        colorBox.style.marginRight = '10px';
                        legendItem.appendChild(colorBox);

                        if (key === 'unknown') {
                            colorBox.style.border = '1px solid black';
                        }

                        legendItem.appendChild(document.createTextNode(longAbsentPresentVarName(key)));

                        legendDiv.appendChild(legendItem);
                    }
                }

                if (document.querySelector('input[name="baseMap"]:checked').value == 'gadm') {
                    var legendItem = document.createElement('p');

                    var colorBox = document.createElement('span');
                    colorBox.style.display = 'inline-block';
                    colorBox.style.width = '20px';
                    colorBox.style.height = '20px';
                    colorBox.style.backgroundColor = '#fffdf2';
                    colorBox.style.border = '1px solid black';
                    colorBox.style.marginRight = '10px';

                    legendItem.appendChild(colorBox);
                    legendItem.appendChild(document.createTextNode('Base map'));

                    legendDiv.appendChild(legendItem);
                }
            }

            function clearSelection() {
                document.getElementById('popup').innerHTML = '';
                shapesData.forEach(function (shape) {
                    shape['weight'] = 0;
                });
                plotPolities();
            }

            function updateCategoricalVariableSelection(variable) {
                var dropdown = document.getElementById('chooseCategoricalVariableSelection');
                dropdown.innerHTML = '';
                if (localStorage.getItem(variable)) {
                    document.getElementById('chooseCategoricalVariableSelection').value = localStorage.getItem(variable);
                }
                if (categorical_variables[variable] && categorical_variables[variable].length > 0) {
                    categorical_variables[variable].forEach(function (choice) {
                        var option = document.createElement('option');
                        option.value = choice;
                        option.text = choice;

                        // Set some default selections if no selection has been made
                        if (localStorage.getItem(variable)) {
                            if (localStorage.getItem(variable) === choice) {
                                option.selected = true;
                            }
                        } else {
                            if (choice === 'Greek' || choice === 'Indo-European') {
                                option.selected = true;
                            }
                        }

                        dropdown.appendChild(option);
                    });
                }
                var varSelectElement = document.getElementById('chooseVariable');
                var varText = varSelectElement.options[varSelectElement.selectedIndex].text;
                document.querySelector('label[for="chooseCategoricalVariableSelection"]').textContent = varText + ': ';
            }

            function longAbsentPresentVarName(var_name) {
                if (var_name === 'A~P') {
                    var_name = 'Absent then Present';
                } else if (var_name === 'P~A') {
                    var_name = 'Present then Absent';
                } else if (var_name === 'unknown') {
                    var_name = 'Coded Unknown';
                } else if (var_name === 'no seshat page') {
                    var_name = 'No Seshat Page';
                } else {
                    var_name = `${var_name[0].toUpperCase()}${var_name.slice(1)}`;
                }
                return var_name;
            }

            function shouldDisplayComponent(displayComponent, shape) {
                if (displayComponent == 'polities'
                    && (shape.member_of === null || shape.member_of === '')) {
                    return true;
                } else if (displayComponent == 'components'
                    && (shape.components === null || shape.components === '')) {
                    return true;
                } else {
                    return false;
                }
            }

            function populateVariableDropdown(variables) {
                const chooseVariableDropdown = document.getElementById('chooseVariable');
                chooseVariableDropdown.innerHTML = ''; // Clear existing options

                // Add the static option
                const staticOption = document.createElement('option');
                staticOption.value = 'polity';
                staticOption.textContent = 'Polity';
                chooseVariableDropdown.appendChild(staticOption);

                // Process 'General Variables' first
                if (variables['General Variables']) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = 'General Variables';
                    Object.entries(variables['General Variables']).forEach(([variable, details]) => {
                        const option = document.createElement('option');
                        option.value = details.formatted;
                        option.textContent = details.full_name;
                        optgroup.appendChild(option);
                    });
                    chooseVariableDropdown.appendChild(optgroup);
                }

                // Process other categories
                Object.entries(variables).forEach(([category, vars]) => {
                    if (category !== 'General Variables') {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = category;
                        Object.entries(vars).forEach(([variable, details]) => {
                            const option = document.createElement('option');
                            option.value = details.formatted;
                            option.textContent = details.full_name;
                            optgroup.appendChild(option);
                        });
                        chooseVariableDropdown.appendChild(optgroup);
                    }
                });
            }

            window.onload = setSliderTicks({{ content.tick_years }});

            var allPolitiesLoaded = false;

            var displayedShapes = [];
            // Load inital polity shapes for the displayed year
            var polityMapShapesData = [
                // JavaScript object representing shape data
                {% for shape in content.shapes %}
                    {
                        {% for key, value in shape.items %}
                            '{{ key }}': '{{ value|escapejs }}',
                        {% endfor %}
                    },
                {% endfor %}
            ];

            allPolitiesLoaded = true;

            // Load capital info
            var capitalsInfo = {{ content.capitals_info | safe }};

            var provinceShapeData;
            var countryShapeData;

            // Load all polity shapes and modern province/country shapes in background
            window.addEventListener('load', function () {
                fetch('/core/provinces_and_countries')
                    .then(response => response.json())
                    .then(data => {
                        provinceShapeData = data.provinces.map(function (shape) {
                            return {
                                geometry: JSON.parse(shape.aggregated_geometry),
                                country: shape.country,
                                province: shape.province,
                                provinceType: shape.province_type
                            };
                        });

                        countryShapeData = data.countries.map(function (shape) {
                            return {
                                geometry: JSON.parse(shape.aggregated_geometry),
                                country: shape.country
                            };
                        });

                        // Enable the radio selection after the fetch request is done
                        document.getElementById('baseMapCurrentLoadingIndicator').style.display = 'none';
                        document.getElementById('baseMapCurrent').disabled = false;
                    });
            });

            var southWest = L.latLng(-89.98155760646617, -180),
                northEast = L.latLng(89.99346179538875, 180),
                bounds = L.latLngBounds(southWest, northEast);

            var map = L.map('map', {
                minZoom: 2,
                maxBounds: bounds,
                maxBoundsViscosity: 1.0
            }).setView([0, 0], 2);

            var baseLayers = {
                "carto": L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}.png'),
                "osm": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png')
            };

            // Select carto as the default base layer
            var currentLayer = baseLayers.carto.addTo(map);
            var provinceLayers = []; // Keep track of province layers to remove them later
            switchBaseMap()

            function plotPolities() {  // This function is defined differently in the world_map template

                var selectedYear = document.getElementById('dateSlide').value;
                var opacity = document.getElementById('opacitySlide').value;

                // Remove all existing layers from the map
                map.eachLayer(function (layer) {
                    if (layer instanceof L.GeoJSON || layer instanceof L.MarkerClusterGroup || layer instanceof L.CircleMarker) {
                        map.removeLayer(layer);
                    }
                });

                // Convert to int, because for some reason JS converts it to a string
                var selectedYearInt = parseInt(selectedYear);

                displayComponent = document.getElementById('switchPolitiesComponents').value;
                // Add shapes to the map
                // Don't plot them if "Base map only" checkbox selected
                if (!document.getElementById('baseMapOnly').checked) {
                    polityMapShapesData.forEach(function (shape) {

                        // If the shape spans the selected year and should be displayed according to the shouldDisplayComponent() function
                        if ((parseInt(shape.start_year) <= selectedYearInt && parseInt(shape.end_year) >= selectedYearInt)
                            && shouldDisplayComponent(displayComponent, shape)
                        ) {

                            // Format the area float
                            const formattedArea = parseFloat(shape.area).toLocaleString('en-US', {
                                minimumFractionDigits: 0,
                                maximumFractionDigits: 0,
                                useGrouping: true
                            });

                            // Format the years
                            if (parseInt(shape.polity_start_year) < 0) {
                                displaystart_year = Math.abs(parseInt(shape.polity_start_year)) + ' BCE';
                            } else {
                                displaystart_year = shape.polity_start_year + ' CE';
                            }

                            if (parseInt(shape.polity_end_year) < 0) {
                                displayend_year = Math.abs(parseInt(shape.polity_end_year)) + ' BCE';
                            } else {
                                displayend_year = shape.polity_end_year + ' CE';
                            }

                            // Add shape
                            var geoJSONLayer = L.geoJSON(JSON.parse(shape.geom_json), {
                                style: function (feature) {
                                    return {
                                        fillColor: shape.colour,  // Set the fill color based on the "colour" field
                                        color: shape.colour,     // Set the border color
                                        weight: 2,              // Set the border weight
                                        fillOpacity: opacity   // Set the fill opacity
                                    };
                                },
                                onEachFeature: function (feature, layer) {
                                    var popupContent = `
                                                <table>
                                                    <tr>
                                                        <th>${shape.name}</th>
                                                        <th></th>
                                                    </tr>
                                            `;
                                    popupContent = popupContent + `
                                                    <tr>
                                                        <td>Duration</td>
                                                        <td>${displaystart_year} to ${displayend_year}</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Area (est.)</td>
                                                        <td>${formattedArea} Km<sup>2</sup></td>
                                                    </tr>
                                                </table>
                                            `;
                                    layer.bindPopup(popupContent);
                                }
                            }).addTo(map);

                            // Plot capital markers       
                            var markers = L.markerClusterGroup({
                                iconCreateFunction: function(cluster) {
                                    return L.divIcon({
                                        html: '<div style="background-color:' + shape.colour + '; color: #fff; border-radius: 50%; text-align: center; line-height: 40px;"><b>' + cluster.getChildCount() + '</b></div>',
                                        className: 'myClusterIcon',
                                        iconSize: L.point(40, 40)
                                    });
                                }
                            });
                            capitalsInfo.forEach(function (capital) {
                                // If the capital existed in the selected year (or years not specified)
                                if ((capital['year_from'] <= selectedYearInt && capital['year_to'] >= selectedYearInt)) {
                                    var marker = L.circleMarker([capital.latitude, capital.longitude], {
                                        color: 'black', // Set the border color
                                        fillColor: shape.colour,  // Set the fill color based on the "colour" field
                                        weight: 2,  // Set the border weight
                                        fillOpacity: 0.5,  // Set the fill opacity
                                        radius: 5
                                    });
                                    marker.bindTooltip(capital.capital, {
                                        permanent: true,
                                        direction: "top",
                                        offset: L.point({ x: 0, y: 0 })
                                    });

                                    marker.bindPopup(capital.capital);
                                    markers.addLayer(marker); // add each marker to the MarkerClusterGroup
                                };
                            });

                            map.addLayer(markers); // add the MarkerClusterGroup to the map

                            // Update the displayedShapes array
                            if (displayedShapes.indexOf(shape.name) === -1) {
                                displayedShapes.push(shape.name);
                            }

                            // adjust the map view to cover the geoJSON layer
                            // but not if there is > 1 shape dataset polity on this polity page
                            if (displayedShapes.length == 1) {
                                map.fitBounds(geoJSONLayer.getBounds());
                            }
                        }
                    });
                };
            }

            // Initial plot on page load
            plotPolities()

            // Display slider value
            var slider = document.getElementById("dateSlide");
            var enterYearInput = document.getElementById("enterYear");
            var output = document.getElementById("sliderDate");
            updateSliderOutput(); // Display the default slider value

            // Update the current slider value (each time you drag the slider handle)
            slider.oninput = function () {
                updateSliderOutput();
                // Sync enterYear input with dateSlide value
                enterYearInput.value = slider.value;
            }

            var playInterval;
            var playRateInput = document.getElementById("playRate");

            // Add event listener to stop playing when adjusting the slider manually
            slider.addEventListener("input", stopPlay);

            // Add event listener to update play rate when the input changes
            playRateInput.addEventListener("change", function () {
                stopPlay(); // Stop current play if ongoing
                startPlay(); // Start with the updated play rate
            });

            // Make sure Radio selection is kept on page refresh
            document.addEventListener("DOMContentLoaded", function () {
                // Get the country parameter from the URL
                var urlParams = new URLSearchParams(window.location.search);

                // Trigger filtering when the page refreshes
                plotPolities();

            });

            // Update the enterYear input value when the user hits return
            enterYearInput.addEventListener("keyup", function (event) {
                if (event.key === "Enter") {
                    // Update the slider value
                    slider.value = enterYearInput.value;
                    updateSliderOutput();
                    plotPolities();
                }
            });

        </script>
    {% endif %}
    {% endblock %}
</body>
